{"data":{"allMdx":{"nodes":[{"fields":{"slug":"/Github Actions을 이용하여 Twitter에 자동으로 글쓰기/","title":"Github Actions을 이용하여 Twitter에 자동으로 글쓰기"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n- GithubAction\n- Python\n- github\n- git\n- 작업일지\ndate: 2022-06-13, 20:38:39\nupdate: 2022-06-13, 22:42:06\ntitle: Github Actions을 이용하여 Twitter에 자동으로 글쓰기\n---\n## TL;DR\n블로그를 포스팅하고 트위터에 글쓰는 것은 너무 귀찮다고 생각한다. 그래서 깃허브에 푸시를 하면 자동으로 트위터에 글을 쓰도록 한다.\n\n## Github Actions 이용하기\nGithub Actions은 github에서 제공하는 워크플로우를 자동화하도록 도와주는 도구이다. 이것을 이용하면 다양한 작업들을 자동화하여 처리할 수 있다.\n\n그렇다면 푸시를 할 때 트위터에 글을 쓰는 스크립트를 실행하도록 설정하면 된다.\n``` yml\n# .github/workflows/Tweet.yml\nname: Tweet\n\non:\n  push:\n    branches:\n      - main\n```\n나는 main 브런치에 커밋을 할 때만 진행하도록 했다.\n\n## 최신 커밋 정보 가져오기\n포스팅을 할 때 새로 커밋한 파일에 대한 것만 트위터에 글을 쓰고 싶다. `git diff`명령어와 옵션을 사용하면 최신 커밋 정보를 가져올 수 있다.\n``` shell\n$ git diff --name-status HEAD~1\nA       Attachments/스크린샷 2022-06-12 오후 8.12.22.png\nA       Test/트윗 테스트.md\n```\n- `--name-status` : 변경 유형과 파일 이름을 알 수 있다.\n- `HEAD~1` :  최근 커밋의 변경 사항을 확인할 수 있다.\n\n파일명의 접두사로 커밋의 변경 상태를 알 수 있다.\n- `A` : 추가 / 새파일\n- `M` : 수정 / 편집\n- `D` : 삭제 / 제거 \n\n나는 새로 추가된 파일 중 마크다운 문서의 이름만 가져오고 싶다. `grep` 명령어를 사용하면 된다. `grep`은 원하는 문자열이 들어간 행을 찾아 출력해준다. `grep`를 통해 새로 추가된 파일을 알아낸다. 그 후 `cut` 명령어를 이용해 필요없는 부분을 제거한다. \n```shell\n$ git diff --name-status HEAD~1 | grep \"^A\" | grep \".md$\" | cut -c 3-\nTest/트윗 테스트.md\n```\n- `grep \"^A\"` : A로 시작되는 경우 출력.\n- `grep \".md$\"` : md로 시작하는 확장자를 가진 경우에만 출력.\n- `cut -c 3-` : 3번째 위치에서 끝까지 문자열을 잘라낸다.\n\n이제 최신 커밋의 파일명을 가져올 수 있다.\n\n## 트위터 개발자 등록 및 라이센스 발급\n트위터 API를 사용하기 위해서는 트위터 개발자 등록과 라이센스를 발급해야한다.\n[Twitter Developer Platform](https://developer.twitter.com/en) 가입 후 프로젝트를 생성하여 앱을 추가해준다. 그사용자 인증은 **OAuth1.0a**로 활성화 해주면 된다. \t`access token`, `access secret token`을 발급 받는다. 해당 부분은 https://jamong-yami.postype.com/post/11433954 페이지에서 자세히 알 수 있다.\n필요한 키는 `API Key`, `API Key Secret`, `Access Token`, `Access Secret Token` 이다.\n\n## 트위터 쓰기 코드 작성\n나는 `Python`을 사용하여 트위터에 글쓰는 코드를 작성했다. 파이썬을 사용한 이유는 조금 익숙한 언어이며 트위터 API를 제공하는 `tweepy` 라이브러리를 사용할 수 있기 때문이다.\n매우 간단하게 코드를 작성했다. \n``` python\n# AutoTweet.py\nimport sys\nimport os\nimport frontmatter\nimport tweepy\n\nimport urllib.parse\n\ndef OAuth():\n\tAPI_KEY = os.environ.get('TWITTER_API_KEY')\n\tAPI_KEY_SECRET = os.environ.get('TWITTER_API_SECRET')\n\tACCESS_TOKEN = os.environ.get('TWITTER_ACCESS_TOKEN_KEY')\n\tACCESS_SECRET = os.environ.get('TWITTER_ACCESS_TOKEN_SECRET')\n\n\tclient = tweepy.Client(consumer_key= API_KEY,consumer_secret= API_KEY_SECRET,access_token= ACCESS_TOKEN,access_token_secret= ACCESS_SECRET)\n\treturn client\n\ndef GetTweetText(file):\n\tsite_url = os.environ.get('SITE_DOMAIN')\n\tfile_name = file.replace('.md','')\n\tpost_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"../\"+file)\n\tpost = frontmatter.load(post_path)\n\tpost_text = \"New Post : \" + post['title'] +\"\\n\" + site_url + urllib.parse.quote(file_name)\n\treturn post_text\n\ndef main():\n\tfile = \" \".join(sys.argv[1:len(sys.argv)])\n\tif not file:\n\t\treturn\n\tclient = OAuth()\n\tclient.create_tweet(text = GetTweetText(file))\n\nif __name__ == \"__main__\":\n\tmain()\n```\n간단하게 소개하며, 파일명을 인자값으로 받아, 글의 제목과 url을 만들고 트위터에 글을 쓰는 함수를 호출한 것이다. 만들면서 신경쓴 것만 정리하고자 한다.\n- `OAuth()` : 트위터 인증을 하는 함수이다.\n\t- 민감한 정보이기 때문에 [GitHub Secrets](https://fatihkalifa.com/twitter-github-actions#:~:text=%EC%B6%94%EA%B0%80%20%EC%B0%B8%EA%B3%A0%20%EC%82%AC%ED%95%AD-,GitHub%20%EB%B9%84%EB%B0%80,-%EA%B8%B0%EB%8A%A5%EC%9D%84%20%EC%82%AC%EC%9A%A9%20%ED%95%98%EC%97%AC) 기능을 사용하여, 환경변수로 값을 얻게 한다.\n- `GetTweetText(file)` : 트위터에 내용을 만들어주는 함수이다.\n\t- `urllib.parse.quote(file_name)` : 파일명이 한글인 경우가 있기 때문에 url 인코딩을 해준다.\n- `file = \" \".join(sys.argv[1:len(sys.argv)])` : 파일명을 인자값으로 받는다. 파일명이 띄어쓰기가 있기 때문에 인자값이 배열로 들어온다. 배열로 들어간 인자값을 하나의 문자열로 만들기 위한 코드이다.\n- `client.create_tweet(text = GetTweetText(file))` : 트위터에 글을 쓰는 기능을 한다.\n\n## 트위터 쓰기 코드 실행하기\n최신 커밋 중 새로 추가한 마크다운 문서의 파일명을 인자값을 가진 트위터를 작성하는 코드를 실행시켜야 한다. `xargs`를 사용하여 파일명을 인자값으로 넘겨서 사용할 수 있다.\n``` shell\n$ git diff --name-status HEAD~1 | grep \".md$\" | grep \"^A\" | cut -c 3- | xargs -L 1 python3 AutoTweet.py\n```\n- `xargs -L 1` : 여러줄을 값을 각각 넘겨준다.\n\n### Github Actions로 실행하기\n``` yml\nname: Tweet\non:\n  push:\n    branches:\n      - main\njobs:\n  tweet:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          fetch-depth: 0\n      - name: Set up Python 3.8\n        uses: actions/setup-python@v2\n        with:\n          python-version: 3.8\n      - name: Install dependencies\n        working-directory: .automatically\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n      - run: git config --global core.quotepath false\n      - name: Share status\n        working-directory: .automatically\n        env:\n          TWITTER_ACCESS_TOKEN_KEY: ${{ secrets.TWITTER_ACCESS_TOKEN }}\n          TWITTER_ACCESS_TOKEN_SECRET: ${{ secrets.TWITTER_ACCESS_TOKEN_SECRET }}\n          TWITTER_API_KEY: ${{ secrets.TWITTER_API_KEY }}\n          TWITTER_API_SECRET: ${{ secrets.TWITTER_API_SECRET }}\n          TWITTER_BEARER_TOKEN_KEY: ${{ secrets.TWITTER_BEARER_TOKEN_KEY }}\n          SITE_DOMAIN: ${{ secrets.SITE_DOMAIN }}\n        run: git diff --name-status HEAD~1 | grep \".md$\" | grep \"^A\" | cut -c 3- | xargs -L 1 python3 AutoTweet.py\n```\n- `- name: Set up Python 3.8` : 파이썬을 설정한다.\n- `- name: Install dependencies` : 필요한 라이브러리를 설치한다.\n- `- run: git config --global core.quotepath false` : 파일명인 경우 한글이 깨지기 때문에 해당 커맨드를 실행하면 한글이 깨지지 않는다.\n- `- name: Share status` : [GitHub Secrets](https://fatihkalifa.com/twitter-github-actions#:~:text=%EC%B6%94%EA%B0%80%20%EC%B0%B8%EA%B3%A0%20%EC%82%AC%ED%95%AD-,GitHub%20%EB%B9%84%EB%B0%80,-%EA%B8%B0%EB%8A%A5%EC%9D%84%20%EC%82%AC%EC%9A%A9%20%ED%95%98%EC%97%AC) 을 사용하여 키를 등록하고 환경변수로 지정한 다음 `AutoTweet.py` 을 실행한다.\n\n이와 같이 하면 새로운 글을 커밋하면 자동으로 트위터를 작성하게 된다.\n## 테스트 결과\n테스트 결과는 [[트윗 테스트]]에서 확인할 수 있다.\n"},{"fields":{"slug":"/Obsidian 데일리 노트에 작성한 글 목록 자동 생성/","title":"Obsidian 데일리 노트에 작성한 글 목록 자동 생성"},"frontmatter":{"draft":false},"rawBody":"---\ntags: \n- obsidian\n- 작업일지\ndate: 2022-07-06, 20:49:04\ntitle: Obsidian 데일리 노트에 작성한 글 목록 자동 생성\ncreate: 2022-07-06 day\nupdate: 2022-07-07, 05:26:17\n---\n## TL;DR\n데일리 노트에 작성한 글 목록을 일일히 입력하는 것이 귀찮다. 그래서 DataView 플러그인을 사용하여 자동으로 입력하게 해본다.\n\n## DataView\n[DataView](https://github.com/blacksmithgu/obsidian-dataview) 는 옵시디언 문서 등에 메타데이터로 주석을 달면 쿼리할 수 있다. 자세한 내용은 해당 웹페이지를 참고하면 된다.\n\n### 쿼리문 작성\n쿼리문을 작성하여 원하는 날짜의 포스터 목록을 가져오도록 한다.\n~~~\n```dateview\nlist\nfrom \"wiki/Post\"\nwhere date = \"2022-07-06 day\"\n```\n~~~\n`wiki/Post` 폴더에서 메타데이터의 date가 `\"2022-07-06 day\"` 인 경우인 문서를 리스트 형식으로 표현해준다. 결과는 다음과 같다.\n![[Pasted image 20220706214658.png]]\n\n하지만 데일리 노트에 일일히 적는 것은 비효율적이다. 데일리노트 생성 시 자동으로 해당 날짜로 자동으로 대입하게 한다.\n\n## Template\n데일리노트는 양식이 있으므로 템플릿을 만들어서 생성하는 것이 좋다. 그것을 도와주는 플러그인은 [Template](https://github.com/SilentVoid13/Templater) 이다.\n\n다양한 기능이 있지만 날짜 생성만 사용할 것이다.\n\n### 데일리 노트 템플릿\n~~~\n```dataview\nlist\nfrom \"wiki/Post\"\nwhere date = \"2022-07-06 day\"\n```\n~~~\n`2022-07-06` 는 `현재년도-월-일`로 표현한다(작성일 기준으로 `2022-07-06` 이다). \n데일리노트 생성 시 해당 부분은 현재 날짜로 변하게 된다. 뒤에 day를 붙인것은 날짜만 하니 쿼리를 하지 못해서 추가했다.\n\n이제 자동으로 쿼리문은 만들어준다. 이제 작성 포스트마다 `date` 메타 데이터를 적어주면 된다. 하지만 이것도 귀찮다. 메타 데이터도 자동으로 생성하도록 한다.\n\n### 포스트 템플릿\n포스트를 작성할 때도 템플릿을 만들어 자동으로 `data` 메타 데이터를 생성한다.\n```\n---\ndate: 2022-07-06 day\n---\n```\n이제 포스트를 작성할때도 해당 템플릿을 사용하면 데일리 노트에서 검색할 수 있는 메타데이터가 생성된다. \n\n나는 이제 쓸데 없는 것 제외하고 본문을 채우는 것만 집중할 수 있다.\n\n### 테스트 결과\n테스트 결과는 [[Obsidian 데일리 노트에 작성한 글 목록 자동 생성 테스트]]에서 확인할 수 있다. 참고로 `dataview`의 쿼리 결과는 옵시디언에서만 확인할 수 있다."},{"fields":{"slug":"/Obsidian과 Gatsby로 홈페이지 만들기/","title":"Obsidian과 Gatsby로 홈페이지 만들기"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n- 작업일지\n- obsidian\n- gatsby\ndate: 2022-06-04, 17:55:14\nupdate: 2022-06-18, 18:43:28\ntitle: Obsidian과 Gatsby로 홈페이지 만들기\n---\n## TL;DR\n기록하기 위해 여러가지 플랫폼을 찾던 중 [Obsidian](https://obsidian.md/)이 있다는 것을 알았다. 몇번 테스트로 사용해보고는 이것을 사용하고자 마음을 먹었다. 이유는 다음과 같다.  \n\n1. 문서 작성도구는 마크다운 형식이어야 한다.\n2. 깃허브를 통해 홈페이지를 만들 수 있어야 한다.\n3. 문서 생성에 관해서 템플릿이 있는 것이 좋다.\n\n이 부분에 대해서 만족했기 때문에 사용해보고자 한다.\n\n## Obsibian Template for Gatsby Theme Primer Wiki 사용하기.\n\nObsidian을 gatsby로 배포할 수 있게 해주는 오픈소스이다.\n\n시작하는 방법은 다음과 같다. 우선 Obsidian 보관함이 있다고 가정하에 진행한다.\n\n1. [깃허브 저장소](https://github.com/theowenyoung/obsidian-template-gatsby-theme-primer-wiki)을 로컬에 클론한다.\n\t```shell\n\tgit clone https://github.com/theowenyoung/obsidian-template-gatsby-theme-primer-wiki.git\n\t```\n2. Obsidian 보관함에 `.layouts`, `.github`, `.gitignore`을 복사한다.\n\n## 로컬에서 확인하기.\n\n```shell\ncd .layouts\nnpm i\nnpm start\n```\n- `npm i` 명령어를 사용해 `package.json` 의존성 패키지를 설치한다.\n- `npm start`로 실행하면 된다.\n\n로컬에서 동작하는 것을 확인할 수 있다.\n\n## 배포하기\n### Path Prefix\n나는 wiki라는 레파지토리를 만들어서 사용할 것이다. 이럴 경우 url은 `{깃아이디}.github.io/wiki`이다. 하지만 배포해보면 url 처리는 `{깃아이디}.github.io`로 된다. 사이트 url뒤에 `/wiki`를 고정시키기 위해서는 다음과 같이 설정해야한다.\n1. `gatsby-config.js` 을 `pathPrefix` 저장소 이름으로 변경한다.\n```js\nmodule.exports = {\npathPrefix: `[저장소 이름]`,\n}\n```\n2. `package.json` 을 변경한다.\n- `\"build\": \"gatsby build --prefix-paths\"`\n- 로컬 미리보기 : `\"serve\": \"gatsby serve --prefix-paths\"`\n\n## Github 설정\n아래와 같이 작업 후 Git에 푸시하면 된다. 그 후 레파지토리 `setting -> pages` 에서 `source`를 `gh-pages`로 설정하면 된다.\n\n깃허브 액션 후 사이트가 배포되면 url로 입력해서 확인하면 된다."},{"fields":{"slug":"/","title":"KEEA WIKI"},"frontmatter":{"draft":false},"rawBody":"---\ntags: \ndate: 2022-06-04, 19:27:15\nupdate: 2022-06-05, 16:26:38\ntitle: KEEA WIKI\n---\n# KEEA WIKI\n**👋 Welcome to my Knowledge Base!**\n"},{"fields":{"slug":"/vscode devcontainer C++/","title":"vscode devcontainer C++"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n- memo\n- vscode\n- c++\ndate: 2022-06-18, 18:49:39\nupdate: 2022-06-18, 20:29:06\ntitle: vscode devcontainer C++\n---\n## TL;DR\nVscode의 devcontainer를 이용하여 C++ 개발 환경 구축한다. `.devcontainer` 폴더만 가지고 있으면 쉽게 개발 환경이 구축된다.\n## 사전 조건\n- Docker : https://www.docker.com/\n- Vscode : https://code.visualstudio.com/\n- Remote Development : https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack\n\n## .devcontainer 생성\n파일 구조는 다음과 같다. `.devcontainer` 파일을 만든후 하위에 `devcontainer.json`, `Dockerfile`, `reinstall-cmake.sh`을 생성한다.\n```\n├── .devcontainer\n    ├── devcontainer.json\n\t├── Dockerfile\n    └── reinstall-cmake.sh\n```\n### devcontainer.json\n```json\n// For format details, see https://aka.ms/devcontainer.json. For config options, see the README at:\n// https://github.com/microsoft/vscode-dev-containers/tree/v0.238.0/containers/cpp\n{\n\t\"name\": \"C++\",\n\t\"build\": {\n\t\t\"dockerfile\": \"Dockerfile\",\n\t\t// Update 'VARIANT' to pick an Debian / Ubuntu OS version: debian-11, debian-10, ubuntu-22.04, ubuntu-20.04, ubuntu-18.04\n\t\t// Use Debian 11, Ubuntu 18.04 or Ubuntu 22.04 on local arm64/Apple Silicon\n\t\t\"args\": { \"VARIANT\": \"ubuntu-22.04\" }\n\t},\n\t\"runArgs\": [\"--cap-add=SYS_PTRACE\", \"--security-opt\", \"seccomp=unconfined\"],\n\n\t// Configure tool-specific properties.\n\t\"customizations\": {\n\t\t// Configure properties specific to VS Code.\n\t\t\"vscode\": {\n\t\t\t// Add the IDs of extensions you want installed when the container is created.\n\t\t\t\"extensions\": [\n\t\t\t\t\"ms-vscode.cpptools\",\n\t\t\t\t\"ms-vscode.cmake-tools\"\n\t\t\t]\n\t\t}\n\t},\n\n\t// Use 'forwardPorts' to make a list of ports inside the container available locally.\n\t// \"forwardPorts\": [],\n\n\t// Use 'postCreateCommand' to run commands after the container is created.\n\t// \"postCreateCommand\": \"gcc -v\",\n\n\t// Comment out to connect as root instead. More info: https://aka.ms/vscode-remote/containers/non-root.\n\t\"remoteUser\": \"vscode\"\n}\n```\n### Dockerfile\n```dockerfile\n# See here for image contents: https://github.com/microsoft/vscode-dev-containers/tree/v0.238.0/containers/cpp/.devcontainer/base.Dockerfile\n\n# [Choice] Debian / Ubuntu version (use Debian 11, Ubuntu 18.04/22.04 on local arm64/Apple Silicon): debian-11, debian-10, ubuntu-22.04, ubuntu-20.04, ubuntu-18.04\nARG VARIANT=\"bullseye\"\nFROM mcr.microsoft.com/vscode/devcontainers/cpp:0-${VARIANT}\n\n# [Optional] Install CMake version different from what base image has already installed. \n# CMake reinstall choices: none, 3.21.5, 3.22.2, or versions from https://cmake.org/download/\nARG REINSTALL_CMAKE_VERSION_FROM_SOURCE=\"none\"\n\n# Optionally install the cmake for vcpkg\nCOPY ./reinstall-cmake.sh /tmp/\nRUN if [ \"${REINSTALL_CMAKE_VERSION_FROM_SOURCE}\" != \"none\" ]; then \\\n        chmod +x /tmp/reinstall-cmake.sh && /tmp/reinstall-cmake.sh ${REINSTALL_CMAKE_VERSION_FROM_SOURCE}; \\\n    fi \\\n    && rm -f /tmp/reinstall-cmake.sh\n\n# [Optional] Uncomment this section to install additional vcpkg ports.\n# RUN su vscode -c \"${VCPKG_ROOT}/vcpkg install <your-port-name-here>\"\n\n# [Optional] Uncomment this section to install additional packages.\n# RUN apt-get update && export DEBIAN_FRONTEND=noninteractive \\\n#     && apt-get -y install --no-install-recommends <your-package-list-here>\n```\n### reinstall-cmake.sh\n```shell\n#!/usr/bin/env bash\n#-------------------------------------------------------------------------------------------------------------\n# Copyright (c) Microsoft Corporation. All rights reserved.\n# Licensed under the MIT License. See https://go.microsoft.com/fwlink/?linkid=2090316 for license information.\n#-------------------------------------------------------------------------------------------------------------\n#\nset -e\n\nCMAKE_VERSION=${1:-\"none\"}\n\nif [ \"${CMAKE_VERSION}\" = \"none\" ]; then\n    echo \"No CMake version specified, skipping CMake reinstallation\"\n    exit 0\nfi\n\n# Cleanup temporary directory and associated files when exiting the script.\ncleanup() {\n    EXIT_CODE=$?\n    set +e\n    if [[ -n \"${TMP_DIR}\" ]]; then\n        echo \"Executing cleanup of tmp files\"\n        rm -Rf \"${TMP_DIR}\"\n    fi\n    exit $EXIT_CODE\n}\ntrap cleanup EXIT\n\n\necho \"Installing CMake...\"\napt-get -y purge --auto-remove cmake\nmkdir -p /opt/cmake\n\narchitecture=$(dpkg --print-architecture)\ncase \"${architecture}\" in\n    arm64)\n        ARCH=aarch64 ;;\n    amd64)\n        ARCH=x86_64 ;;\n    *)\n        echo \"Unsupported architecture ${architecture}.\"\n        exit 1\n        ;;\nesac\n\nCMAKE_BINARY_NAME=\"cmake-${CMAKE_VERSION}-linux-${ARCH}.sh\"\nCMAKE_CHECKSUM_NAME=\"cmake-${CMAKE_VERSION}-SHA-256.txt\"\nTMP_DIR=$(mktemp -d -t cmake-XXXXXXXXXX)\n\necho \"${TMP_DIR}\"\ncd \"${TMP_DIR}\"\n\ncurl -sSL \"https://github.com/Kitware/CMake/releases/download/v${CMAKE_VERSION}/${CMAKE_BINARY_NAME}\" -O\ncurl -sSL \"https://github.com/Kitware/CMake/releases/download/v${CMAKE_VERSION}/${CMAKE_CHECKSUM_NAME}\" -O\n\nsha256sum -c --ignore-missing \"${CMAKE_CHECKSUM_NAME}\"\nsh \"${TMP_DIR}/${CMAKE_BINARY_NAME}\" --prefix=/opt/cmake --skip-license\n\nln -s /opt/cmake/bin/cmake /usr/local/bin/cmake\n```\n\n## VSCode에서 컨테이너로 원격 연결\n![[Pasted image 20220618194716.png]]\n위와 같이 창이 뜨면 `Reopen in Container`를 누른다.\n\n혹은 명령어 팔레트에서 `Remote-Containers: Open Folder in Containers...`를 실행한다.\n\n![[Pasted image 20220618195027.png]]\nC++를 개발할 수 있는 도커 컨테이너에 접속할 수 있다.\n\n### CMake 설정하기\n1. 명령어 팔레트에서 `Cmake: Configure`를 실행한다.\n2. 컴파일러를 선택한다.(GCC 또는 Clang)\n\t![[Pasted image 20220618195732.png]]\n3. 아래와 같은 창이 뜨면 `Create`를 선택한다. \n\t![[Pasted image 20220618195209.png]]\n4. 프로젝트명 입력한다.\n\t![[Pasted image 20220618195339.png]]\n5. 라이브러리(Libray), 실행파일(Executable) 중 만들 것을 선택한다.\n\t![[Pasted image 20220618195454.png]]\n### 빌드 및 디버깅\n- `[F7] (F7)` : 빌드\n- `[F5] (F5)` : 디버깅 시작\n- `⌃ F5 (Ctrl + F5)` : 디버깅 없이 시작"},{"fields":{"slug":"/Test/Obsidian 데일리 노트에 작성한 글 목록 자동 생성 테스트/","title":"Obsidian 데일리 노트에 작성한 글 목록 자동 생성 테스트"},"frontmatter":{"draft":false},"rawBody":"---\ntags: \n- test\ndate: 2022-07-06, 20:32:08\ntitle: Obsidian 데일리 노트에 작성한 글 목록 자동 생성 테스트\ncreate: 2022-07-06 day \nupdate: 2022-07-07, 05:26:07\n---\n## TL;DR\n옵시디언에서 데일리 노트에서 해당 날짜에 작성한 글 목록 표시 테스트.\n\n## 결과\n![[Pasted image 20220706214658.png]]\n"},{"fields":{"slug":"/Test/트윗 테스트/","title":"트윗 테스트"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n- test\nupdate: 2022-06-12, 20:22:17\ndate: 2022-06-12, 19:48:37\ntitle: 트윗 테스트\n---\n## TL;DR\n옵시디언으로 작성한 글을 발생했을 때 자동으로 트위터에 글쓰기 테스트.\n\n## 결과\n![[스크린샷 2022-06-12 오후 8.12.22.png]]"},{"fields":{"slug":"/placeholder/","title":"This Is a Placeholder File for Mdx"},"frontmatter":{"draft":true},"rawBody":"---\ntitle: This Is a Placeholder File for Mdx\ndraft: true\ntags:\n  - gatsby-theme-primer-wiki-placeholder\n---\n"}]}}}